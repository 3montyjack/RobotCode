#pragma config(Sensor, S1,     LeftLight,      sensorLightActive)
#pragma config(Sensor, S4,     RightLight,     sensorLightActive)
#pragma config(Motor,  motorA,          LeftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          RightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//This is the set threshold I think we got somewhere from 40 to 50 will work

int satThreshold = 45;
int speedMotor = 20;
int direction = 1;

enum Directions
{
	forwardDir = 0,
	leftSoft = 45,
	rightSoft = -45,
	leftHard = 99,
	rightHard = -99

};

enum Speed
{
	normal = 20,
	softTurn = 25,
	hardTurn = 20,
}

bool cornerLeft;
bool cornerRight;

bool enableLights = false;
int stateLightSensor = 0;
int lastStateLightSensor = 0;

enum SensorValues
{
	noneDark,
	leftDark,
	rightDark,
	bothDark
};

task moveSense() {
	short leftColor = 0;
	short rightColor = 0;

	while(true) {
		if (enableLights) {
			lastStateLightSensor = stateLightSensor;
			//If equal to the last then go straight
			// if last was both black then veer right
			// if color is white and last was black then reverse and turn?
			// if color is white and one was black turn to the one that was black and reverse a bit
			// have a wait at the end
			leftColor = SensorValue(LeftLight);
			rightColor = SensorValue(RightLight);



			if (leftColor > satThreshold && rightColor > satThreshold){
				// If the color is white on each then
				stateLightSensor = noneDark;
			}

			if (rightColor < satThreshold && leftColor < satThreshold) {
				// If the color is black on each then
				stateLightSensor = bothDark;
			}

			if (leftColor > satThreshold && rightColor < satThreshold) {
				// If the color is white only on the left
				stateLightSensor = rightDark;
			}

			if (rightColor > satThreshold && leftColor < satThreshold) {
				// If the color is white only on the left
			stateLightSensor = leftDark;
			}

			wait1Msec(3);
		}
		else {
			wait1Msec(100);
		}
	}
	releaseCPU();

}

task main()
{
	//begins subthread
	startTask(moveSense);
	enableLights = true;
	cornerLeft = false;
	cornerRight = false;
	while(true) {
		//if no line is found
		if ((stateLightSensor == noneDark)) {
			direction = forwardDir;
			speedMotor = normal;
		}
		//veer left when left sensor detects line
		if ((stateLightSensor == leftDark)) {
				direction = rightSoft;
				speedMotor = softTurn;
		}
		//veer right when right sensor detects line
		if ((stateLightSensor == rightDark)) {
			direction = leftSoft;
			speedMotor = softTurn;
		}



		//if both sensors see black, indicating a sharp turn, will decide which way to turn hard
		if (stateLightSensor == bothDark) {
			if (direction == leftSoft) {
				direction = leftHard;
				speedMotor = hardTurn;

			}
			if (direction == rightSoft) {
				direction = rightHard;
				speedMotor = hardTurn;

			}
			if (direction == forwardDir) {
				direction = leftHard;
				speedMotor = hardTurn;
			}
		}

		setMotorSync(LeftMotor, RightMotor, direction, speedMotor);
		wait1Msec(1);
	}
	releaseCPU();


}
