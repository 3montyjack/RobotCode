#pragma config(Sensor, S1,     WallSensor,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     ColorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     BallSensor,     sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          LeftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          ClawGrab,     tmotorNXT, PIDControl)
#pragma config(Motor,  motorC,          ClawVertical,   tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorD,          RightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/* Mnemonics for motion control */ //copied from emailed example
enum Movement {
	HALT = 0,
	FWD = 1,
	BWD = 2,
	LEFT_ARC = 3,
	RIGHT_ARC = 4,
	LEFT_TURN = 5,
	RIGHT_TURN = 6,
	HARD_LEFT = 7
};

/* Mnemonics for motor speed control */
enum MotorValues {
	FORD = 80,
	SYNCH = 0,
	ARCING = 10,
	FORWARDTIMEUNIT = 600,
	ARCRATIO = 70,
	TURNCLICKCOUNT = 175,
	STOPMOVEMENT = 0
};

enum ClawStates {
	CLAWCLOSE,
	CLAWOPEN,
	CLAWHOLD,
	CLAWTOHOLD,
	CLAWTODROP,
	CLAWTOGROUND
};

enum ClawControlValues {
	CLAWDOWNM = -10,
	CLAWUPM = 55,
	CLAWCLOSEM = 30,
	CLAWOPENM = -30,
	CLAWHOLDM = 3
};

enum TimingMotors {
	timeTillClawMoves = 200
};

enum EncoderValues {
	CLAWHOLDE = 80,
	CLAWDROPE = 110
};

enum SensorTolerances {
	tolleranceBall = 0,
	tolleranceClawFloor = 15,
	deltaDistanceSensors = 5
};

enum SensorThreshold {
	pickupThreshold = 30
};

int robot_lever_command;
int robot_claw_command;
int robot_drive_command;

int search_motor_command;
int search_claw_command;
int search_lever_command;

int grabbing_motor_command;
int grabbing_claw_command;
int grabbing_lever_command;


int depositing_motor_command;
int depositing_claw_command;
int deposting_lever_command;

//Booleans to see what state the robot is in

bool searching = false;
bool foundBall = false;
bool depositingBall = false;

//Initialize behavior flags






int motorEncoder;







//This function will take in an int representing what operation it should do
//and translates this into motor controls.  It is also from the emailed example.
task moveCommand () {
	while(true) {
		switch (robot_drive_command) {
		case FWD:
			setMotorSyncTime (LeftMotor, RightMotor, SYNCH, FORWARDTIMEUNIT, FORD);
			break;

		case BWD:
			setMotorSyncTime (LeftMotor, RightMotor, SYNCH, FORWARDTIMEUNIT, -FORD);
			break;

		case LEFT_TURN:
			setMotorSyncEncoder (LeftMotor, RightMotor, 100, TURNCLICKCOUNT, FORD);
			break;

		case RIGHT_TURN:
			setMotorSyncEncoder (LeftMotor, RightMotor, -100, TURNCLICKCOUNT, FORD);
			break;

		case LEFT_ARC:
			setMotorSyncTime (LeftMotor, RightMotor, ARCING, FORWARDTIMEUNIT, FORD);
			break;

		case RIGHT_ARC:
			setMotorSyncTime (LeftMotor, RightMotor, -ARCING, FORWARDTIMEUNIT, FORD);
			break;

		case HARD_LEFT:
			setMotorSyncTime (LeftMotor, RightMotor, SYNCH, FORWARDTIMEUNIT, -FORD);
			sleep(800);
			setMotorSyncEncoder (LeftMotor, RightMotor, 100, 90, FWD);
			break;
		}
		releaseCPU();
	}
}


task controlClaw() {
	// Need to deal with encoder values to protect the motor?
	while(true) {
		switch(robot_claw_command) {
		case CLAWCLOSE:
			setMotor(ClawGrab, CLAWCLOSEM);
			break;
		case CLAWOPEN:
			setMotor(ClawGrab, CLAWOPENM);
			break;
		}
		releaseCPU();
	}
}



task leverCommands() {

	while(true) {

		switch(robot_lever_command) {
			case CLAWHOLD:
				setMotor(ClawVertical, CLAWHOLDM);
				break;
			case CLAWTODROP:
				setMotor(ClawVertical, CLAWUPM);
				break;
			case CLAWTOGROUND:
				if (getMotorEncoder(ClawVertical) > tolleranceClawFloor) {
					setMotor(ClawVertical, CLAWDOWNM);
				}
				break;
			case CLAWTOHOLD:
				while (getMotorEncoder(ClawVertical) > CLAWHOLDE + 5 || getMotorEncoder(ClawVertical) < CLAWHOLDE - 5){
					motorEncoder = getMotorEncoder(ClawVertical);
					if (getMotorEncoder(ClawVertical) > CLAWHOLDE) {
						setMotor(ClawVertical, CLAWDOWNM);
						} else if (getMotorEncoder(ClawVertical) < CLAWHOLDE) {
						setMotor(ClawVertical, CLAWUPM);
						} else {
						setMotor(ClawVertical, CLAWHOLDM);
					}
				}
				break;
			}
			releaseCPU();
	}
}




// This is the thread that controls the top downward facing reflection sensor. As a cockroach, the robot behavior is to stop
// when appropriate darkeness is sensed.

task searchForBallTask() {
	int topDistanceSensor;
	int bottomDistanceSensor;

	bool passedThreshold;

	int startEncoderValue;
	int currentRotation;

	while (true) {
		//TODO: Fix the sensor ports/ THere is a better command for finding the value anyways
		topDistanceSensor = SensorValue[WallSensor];
		bottomDistanceSensor = SensorValue[BallSensor];

		if (searching) {

			// Start spinning
				// Record the xy that we are currently at

			if (!passedThreshold) {
				passedThreshold = true;
				startEncoderValue = getMotorEncoder(LeftMotor);
				currentRotation = 0;

				search_claw_command = CLAWOPEN;
				search_motor_command = STOPMOVEMENT;
				search_lever_command = CLAWTOGROUND;

				//updateXY

			} else {
				// Math on degrees is find the center of rotation and such
					// Easy way record the encoder value for 360 degreee turn mutaple times, and get a ratio for how many degrees the motor turned and the degrees of the robot turn
				// curretnRotation + delta(startEncoderValue) ++ or something, roll over after 360


			}


			//Case for reconizing a wall - recording local max, when goes down past threshold record corner
				// Record relativeish direction of the wall


			//Case for returning back to start
				// Reset the wall count


			// If wall in front and not straight on assume side, thus just going forward
			if (direction < startEncoderValue) {
				search_claw_command = CLAWOPEN;
				search_motor_command = STOPMOVEMENT;
				search_lever_command = CLAWTOGROUND;
			}

			if ((bottomDistanceSensor + deltaDistanceSensors) < (topDistanceSensor - tolleranceBall)) {
				foundBall = true;
				//TODO : make these vars turningMax turningDistance
			}





			// if wall is in front assume that we need to turn left or right



			// if corner can only turn one way


		}







		releaseCPU();
	}
}

bool pickingUp = false;

task grabbingBallTask() {
	int topDistanceSensor;
	int bottomDistanceSensor;

	while (true) {
		if (pickingUp) {
			//TODO: Fix the sensor ports/ THere is a better command for finding the value anyways
			topDistanceSensor = SensorValue[WallSensor];
			bottomDistanceSensor = SensorValue[BallSensor];

			grabbing_motor_command = FWD;

			if (bottomDistanceSensor <= pickupThreshold) {
				grabbing_claw_command = CLAWOPEN;
				grabbing_motor_command = STOPMOVEMENT;
				grabbing_lever_command = CLAWTOGROUND;
			}
			if (getMotorEncoder(ClawVertical) < tolleranceClawFloor) {
				grabbing_claw_command = CLAWOPEN;
				grabbing_motor_command = STOPMOVEMENT;
				grabbing_lever_command = CLAWTOGROUND;
				pickingUp = true;
			}

			if (pickingUp) {
				grabbing_lever_command = CLAWTODROP;
				if (getMotorEncoder(ClawVertical) < CLAWDROPE) {
					grabbing_motor_command = STOPMOVEMENT;
					grabbing_lever_command = CLAWTOGROUND;
					sleep(timeTillClawMoves); //TODO : Fix these waits to be more accurate / move them to the movement parts
					grabbing_claw_command = CLAWCLOSE;
					grabbing_lever_command = CLAWTOHOLD;
					grabbing_motor_command = FWD;
					sleep(10);
					pickingUp = false;
					searching = false;
					depositingBall = true;

				}
			}
			sleep(5);

		}
		releaseCPU();
	}
}




//This will begin all appropriate threads, one for arbitrater, the bumper, the right hand sonar sensor
// and one for the upward facing light sensor
task main() {
	int motorCommands;
	int clawCommands;
	int leverControl;

	//startTask(obstacle_Bumper_Hit);
	//startTask(wall_follow);
	startTask(moveCommand);
	startTask(searchForBallTask);
	startTask(grabbingBallTask);
	startTask(leverCommands);
	startTask(controlClaw);
	//startTask(depositingBallTask);

	robot_lever_command = CLAWTOHOLD;
	robot_claw_command = CLAWOPEN;

	while(true) {
		motorCommands = FWD;
		motorEncoder = getMotorEncoder(ClawVertical);
		if (searching) {
			motorCommands = search_motor_command;
			clawCommands = search_claw_command;
			leverControl = search_lever_command;
		}

		if (pickingUp) {
			motorCommands = grabbing_motor_command;
			clawCommands = grabbing_claw_command;
			leverControl = grabbing_lever_command;
		}

		if (depositingBall) {
			motorCommands = depositing_motor_command;
			clawCommands = depositing_claw_command;
			leverControl = deposting_lever_command;
		}



		robot_move_command = motorCommands;
		robot_claw_command = clawCommands;
		robot_lever_command = leverControl;
		releaseCPU();
	}


}
