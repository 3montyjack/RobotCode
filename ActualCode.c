#pragma config(Sensor, S1,     WallSensor,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     ColorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     BallSensor,     sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          LeftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          ClawGrab,     tmotorNXT, PIDControl)
#pragma config(Motor,  motorC,          ClawVertical,   tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorD,          RightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/* Mnemonics for motion control */ //copied from emailed example
enum Movement {
	HALT = 0,
	FWD = 1,
	BWD = 2,
	LEFT_ARC = 3,
	RIGHT_ARC = 4,
	LEFT_TURN = 5,
	RIGHT_TURN = 6,
	HARD_LEFT = 7
}

/* Mnemonics for motor speed control */
enum MotorValues {
	FORD = 80,
	SYNCH = 0,
	ARCING = 10,
	FORWARDTIMEUNIT = 600,
	ARCRATIO = 70,
	TURNCLICKCOUNT = 175,
	STOPMOVEMENT = 0
}

enum ClawStates {
	CLAWCLOSE,
	CLAWOPEN,
	CLAWHOLD,
	CLAWTOHOLD,
	CLAWTODROP,
	CLAWTOGROUND
}

enum ClawControlValues {
	CLAWDOWNM = -10,
	CLAWUPM = 55,
	CLAWCLOSEM = 30,
	CLAWOPENM = -30,
	CLAWHOLDM = 3
}

enum TimingMotors {
	timeTillClawMoves = 200
}

enum EncoderValues {
	CLAWHOLDE = 80,
	CLAWDROPE = 110
}

enum SensorTolerances {
	tolleranceBall = 0,
	tolleranceClawFloor = 15,
	deltaDistanceSensors = 5
}

enum SensorThreshold {
	pickupThreshold = 30
}

int robot_lever_command;

int search_motor_command;
int search_claw_command;
int search_lever_command;

int grabbing_motor_command;
int grabbing_claw_command;
int grabbing_lever_command;


int depositing_motor_command;
int depositing_claw_command;
int deposting_lever_command;

//Booleans to see what state the robot is in

bool searching = false;
bool foundBall = false;
bool depositingBall = false;

//Initialize behavior flags






int motorEncoder;







//This function will take in an int representing what operation it should do
//and translates this into motor controls.  It is also from the emailed example.
void Move (int operation) {

	switch (operation) {
	case FWD:
		setMotorSyncTime (LeftMotor, RightMotor, SYNCH, FORWARDTIMEUNIT, FORD);
		break;

	case BWD:
		setMotorSyncTime (LeftMotor, RightMotor, SYNCH, FORWARDTIMEUNIT, -FORD);
		break;

	case LEFT_TURN:
		setMotorSyncEncoder (LeftMotor, RightMotor, 100, TURNCLICKCOUNT, FORD);
		break;

	case RIGHT_TURN:
		setMotorSyncEncoder (LeftMotor, RightMotor, -100, TURNCLICKCOUNT, FORD);
		break;

	case LEFT_ARC:
		setMotorSyncTime (LeftMotor, RightMotor, ARCING, FORWARDTIMEUNIT, FORD);
		break;

	case RIGHT_ARC:
		setMotorSyncTime (LeftMotor, RightMotor, -ARCING, FORWARDTIMEUNIT, FORD);
		break;

	case HARD_LEFT:
		setMotorSyncTime (LeftMotor, RightMotor, SYNCH, FORWARDTIMEUNIT, -FORD);
		sleep(800);
		setMotorSyncEncoder (LeftMotor, RightMotor, 100, 90, FWD);
		break;
	}
	sleep (1000);
}


void controlClaw(int operation) {

	switch(operation) {
	case CLAWCLOSE:
		setMotor(ClawGrab, CLAWCLOSEM);
		break;
	case CLAWOPEN:
		setMotor(ClawGrab, CLAWOPENM);
		break;
	}

}

bool here = false;

task leverCommands() {

	while(true) {
		here = true;
		switch(robot_lever_command) {
			case CLAWHOLD:
				setMotor(ClawVertical, CLAWHOLDM);
				break;
			case CLAWTODROP:
				setMotor(ClawVertical, CLAWUPM);
				break;
			case CLAWTOGROUND:
			if (getMotorEncoder(ClawVertical) > tolleranceClawFloor) {

				setMotor(ClawVertical, CLAWDOWNM);
			}
				break;
			case CLAWTOHOLD:
				while (getMotorEncoder(ClawVertical) > CLAWHOLDE + 5 || getMotorEncoder(ClawVertical) < CLAWHOLDE - 5){

					motorEncoder = getMotorEncoder(ClawVertical);
					if (getMotorEncoder(ClawVertical) > CLAWHOLDE) {
						setMotor(ClawVertical, CLAWDOWNM);
						} else if (getMotorEncoder(ClawVertical) < CLAWHOLDE) {
						setMotor(ClawVertical, CLAWUPM);
						} else {
						setMotor(ClawVertical, CLAWHOLDM);
					}
				}
				break;
			}
			releaseCPU();
	}
}

// This is the thread that controls the top downward facing reflection sensor. As a cockroach, the robot behavior is to stop
// when appropriate darkeness is sensed.

task searchForBallTask() {
	int topDistanceSensor;
	int bottomDistanceSensor;
	while (true) {
		//TODO: Fix the sensor ports/ THere is a better command for finding the value anyways
		topDistanceSensor = SensorValue[WallSensor];
		bottomDistanceSensor = SensorValue[BallSensor];

		if (searching) {
			if ((bottomDistanceSensor + deltaDistanceSensors) < (topDistanceSensor - tolleranceBall)) {
				foundBall = true;
				//TODO : make these vars turningMax turningDistance
			}
			// Start spinning



			// If wall in front and not straight on assume side


			// if wall is in front assume that we need to turn left or right


			// if corner can only turn one way





		}







		releaseCPU();
	}
}

bool pickingUp = false;

task grabbingBallTask() {
	int topDistanceSensor;
	int bottomDistanceSensor;

	while (true) {
		if (pickingUp) {
			//TODO: Fix the sensor ports/ THere is a better command for finding the value anyways
			topDistanceSensor = SensorValue[WallSensor];
			bottomDistanceSensor = SensorValue[BallSensor];

			grabbing_motor_command = FWD;

			if (bottomDistanceSensor <= pickupThreshold) {
				grabbing_claw_command = CLAWOPEN;
				grabbing_motor_command = STOPMOVEMENT;
				grabbing_lever_command = CLAWTOGROUND;
			}
			if (getMotorEncoder(ClawVertical) < tolleranceClawFloor) {
				grabbing_claw_command = CLAWOPEN;
				grabbing_motor_command = STOPMOVEMENT;
				grabbing_lever_command = CLAWTOGROUND;
				pickingUp = true;
			}

			if (pickingUp) {
				grabbing_lever_command = CLAWTODROP;
				if (getMotorEncoder(ClawVertical) < CLAWDROPE) {
					grabbing_motor_command = STOPMOVEMENT;
					grabbing_lever_command = CLAWTOGROUND;
					sleep(timeTillClawMoves);
					grabbing_claw_command = CLAWCLOSE;
					grabbing_lever_command = CLAWTOHOLD;
					grabbing_motor_command = FWD;
					sleep(10);
					pickingUp = false;
					searching = false;
					depositingBall = true;

				}
			}
			sleep(5);

		}
		releaseCPU();
	}
}




//This will begin all appropriate threads, one for arbitrater, the bumper, the right hand sonar sensor
// and one for the upward facing light sensor
task main() {
	int motorCommands;
	int clawCommands;
	int leverControl;

	//startTask(obstacle_Bumper_Hit);
	//startTask(wall_follow);

	startTask(searchForBallTask);
	startTask(grabbingBallTask);
	startTask(leverCommands);
	//startTask(depositingBallTask);

	robot_lever_command = CLAWTOHOLD;
	controlClaw(CLAWOPEN);

	while(true) {
		motorCommands = FWD;
		motorEncoder = getMotorEncoder(ClawVertical);
		if (searching) {
			motorCommands = search_motor_command;
			clawCommands = search_claw_command;
			leverControl = search_lever_command;
		}

		if (pickingUp) {
			motorCommands = grabbing_motor_command;
			clawCommands = grabbing_claw_command;
			leverControl = grabbing_lever_command;
		}

		if (depositingBall) {
			motorCommands = depositing_motor_command;
			clawCommands = depositing_claw_command;
			leverControl = deposting_lever_command;
		}



		Move(motorCommands);
		controlClaw(clawCommands);

		robot_lever_command = leverControl;
		sleep(1);
		releaseCPU();
	}


}
