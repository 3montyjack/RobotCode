#pragma config(Sensor, S1,     WallSensor,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     ,               sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     ColorSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     BallSensor,     sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          LeftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          ClawGrab,      tmotorNXT, PIDControl)
#pragma config(Motor,  motorC,          ClawVertical,  tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorD,          RightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Mnemonics for motion control */ //copied from emailed example
enum Movement {
	HALT,
	FWD,
	BWD,
	LEFT_ARC,
	RIGHT_ARC,
	LEFT_TURN,
	HARD_RIGHT,
	HARD_LEFT,
	RIGHT_TURN,
	NORMAL_SEARCH,
	HARD_LEFT_SEARCH,
	HARD_RIGHT_SEARCH,
	FORWARD_MOVE_SEARCH
};

enum Direction {
	NORTH,
	EAST,
	SOUTH,
	WEST
};

/* Mnemonics for motor speed control */
enum MotorValues {
	FORD = 80,
	SYNCH = 0,
	HALT_VALUE = 0,
	HARD_LEFT_VALUE = 45,
	ARCING = 10,
	FORWARDTIMEUNIT = 600,
	ARCRATIO = 70,
	TURNCLICKCOUNT = 175,
	HARD_TURN = 99,
	STOPMOVEMENT = 0
};

enum TuringValues {
	HARD_RIGHT_VALUE = 75,
	FORWARD_VALUE = 0
};

enum ClawStates {
	CLAWCLOSE,
	CLAWOPEN,
	CLAWHOLD,
	CLAWTOHOLD,
	CLAWTODROP,
	CLAWTOGROUND
};

enum ClawControlValues {
	CLAWDOWNM = -10,
	CLAWUPM = 55,
	CLAWCLOSEM = 30,
	CLAWOPENM = -30,
	CLAWHOLDM = 3
};

enum TimingMotors {
	timeTillClawMoves = 200
};

enum EncoderValues {
	CLAWHOLDE = 80,
	CLAWDROPE = 110,
	MAX_ROTATION = 1900
};

enum SensorTolerances {
	tolleranceBall = 0,
	tolleranceClawFloor = 15,
	deltaDistanceSensors = 7,

};

enum SensorThreshold {
	pickupThreshold = 30,
	SENSOR_DIST_TOP_MAX = 50,
	WALL_THRESHOLD_2ND = 20
};

// TODO: Implement these

bool enable_robot_lever;
bool enable_robot_claw;
bool enable_robot_drive;

// END TODO

int robot_lever_command;
int robot_claw_command;
int robot_drive_command;

int search_motor_command;
int search_claw_command;
int search_lever_command;

int grabbing_motor_command;
int grabbing_claw_command;
int grabbing_lever_command;

int depositing_motor_command;
int depositing_claw_command;
int deposting_lever_command;

//Booleans to see what state the robot is in

bool searching = false;
bool foundBall = false;
bool depositingBall = false;

// Location Tracking for later

int currentX = 0;
int currentY = 0;

int exploredX = -1;
int exploredY = -1;



//Debug global values

int motorEncoder;
int wallAmmount = 0;






//This function will take in an int representing what operation it should do
//and translates this into motor controls.  It is also from the emailed example.
task moveCommand () {
	while(true) {
		switch (robot_drive_command) {
		case FWD:
			setMotorSyncTime (LeftMotor, RightMotor, SYNCH, FORWARDTIMEUNIT, FORD);
			break;
		case BWD:
			setMotorSyncTime (LeftMotor, RightMotor, SYNCH, FORWARDTIMEUNIT, -FORD);
			break;
		case HALT:
			setMotorSync (LeftMotor, RightMotor, 0, HALT_VALUE);
			break;
		case HARD_RIGHT:
			setMotorSync (LeftMotor, RightMotor, 100, FORD);
			break;
		case HARD_LEFT_SEARCH:
			setMotorSyncTime (LeftMotor, RightMotor, SYNCH, FORWARDTIMEUNIT, FORD);
			sleep(FORWARDTIMEUNIT);
			setMotorSyncEncoder (LeftMotor, RightMotor, 100, 90, FWD);
			break;
		case HARD_RIGHT_SEARCH:
			setMotorSyncTime (LeftMotor, RightMotor, SYNCH, FORWARDTIMEUNIT, FORD);
			sleep(FORWARDTIMEUNIT);
			setMotorSyncEncoder (LeftMotor, RightMotor, 100, 90, FWD);
			break;
		case NORMAL_SEARCH:
			setMotorSync (LeftMotor, RightMotor, HARD_TURN, FORD);
			break;
		case FORWARD_MOVE_SEARCH:
			setMotorSync (LeftMotor, RightMotor, FORWARD_VALUE, FORD);
			sleep(800); // TODO : CHANGE FOR THE CORRECT DISTANCE OR SLEEP TILL PROPER ENCODER VALUE
			// Also probs possible to use pid drive which would allow for perfectly straight driving
			break;
		}
		releaseCPU();
	}
}


task controlClaw() {
	// Need to deal with encoder values to protect the motor?
	while(true) {
		switch(robot_claw_command) {
		case CLAWCLOSE:
			setMotor(ClawGrab, CLAWCLOSEM);
			break;
		case CLAWOPEN:
			setMotor(ClawGrab, CLAWOPENM);
			break;
		}
		releaseCPU();
	}
}



task leverCommands() {

	while(true) {

		switch(robot_lever_command) {
		case CLAWHOLD:
			setMotor(ClawVertical, CLAWHOLDM);
			break;
		case CLAWTODROP:
			setMotor(ClawVertical, CLAWUPM);
			break;
		case CLAWTOGROUND:
			if (getMotorEncoder(ClawVertical) > tolleranceClawFloor) {
				setMotor(ClawVertical, CLAWDOWNM);
			}
			break;
		case CLAWTOHOLD:
			while (getMotorEncoder(ClawVertical) > CLAWHOLDE + 5 || getMotorEncoder(ClawVertical) < CLAWHOLDE - 5){
				motorEncoder = getMotorEncoder(ClawVertical);
				if (getMotorEncoder(ClawVertical) > CLAWHOLDE) {
					setMotor(ClawVertical, CLAWDOWNM);
					} else if (getMotorEncoder(ClawVertical) < CLAWHOLDE) {
					setMotor(ClawVertical, CLAWUPM);
					} else {
					setMotor(ClawVertical, CLAWHOLDM);
				}
			}
			break;
		}
		releaseCPU();
	}

}




// This is the thread that controls the top downward facing reflection sensor. As a cockroach, the robot behavior is to stop
// when appropriate darkeness is sensed.

int topDistanceSensor;
int bottomDistanceSensor;

int topDistanceSensorFound;
int bottomDistanceSensorFound;

int currentRotation;

bool wall1;
bool wall2;
bool wall3;
bool wall4;

task searchForBallTask() {


	bool passedThreshold;

	int startEncoderValue;


	int localWallMax = -1;
	bool walls[4] = {false, false, false, false};
	bool turnLeft = false;



	while (true) {

		wall1 = walls[0];
		wall2 = walls[1];
		wall3 = walls[2];
		wall4 = walls[3];
		//TODO: Fix the sensor ports/ THere is a better command for finding the value anyways
		topDistanceSensor = SensorValue[WallSensor];
		bottomDistanceSensor = SensorValue[BallSensor];
		currentRotation = getMotorEncoder(RightMotor) - startEncoderValue;

		if (searching) {

			// Start spinning
			// Record the xy that we are currently at

			if (currentRotation > (startEncoderValue + MAX_ROTATION)) {
				// Initalizing the next search

				passedThreshold = true;
				startEncoderValue = getMotorEncoder(RightMotor);
				currentRotation = 0;

				search_claw_command = CLAWOPEN;
				search_motor_command = STOPMOVEMENT;
				search_lever_command = CLAWTOHOLD;

				walls[0] = false;
				walls[1] = false;
				walls[2] = false;
				walls[3] = false;
				localWallMax = -1;

				//updateXY

			} else {


				// Move Forward state

				search_claw_command = CLAWOPEN;
				search_motor_command = NORMAL_SEARCH;
				search_lever_command = CLAWTOHOLD;

				// If wall in front and not straight on assume side, thus just going forward
				if (currentRotation > (startEncoderValue + MAX_ROTATION)) {

					search_claw_command = CLAWOPEN;
					search_motor_command = FORWARD_MOVE_SEARCH;
					search_lever_command = CLAWTOHOLD;


					if (walls[0]) {
						//Turn left or right based on local var
						// Wait some seconds
						search_claw_command = CLAWOPEN;
						if (turnLeft) {
							search_motor_command = HARD_LEFT_SEARCH;
							direction = changeDirection(direction, true);
						} else {
							search_motor_command = HARD_RIGHT_SEARCH;
							direction = changeDirection(direction, false);
						}
						search_lever_command = CLAWTOHOLD;


					}

					if (walls[0] && walls[1]) {
						// Turn left uninterupted
						// Wait some seconds
						search_claw_command = CLAWOPEN;
						search_motor_command = HARD_LEFT_SEARCH;
						direction = changeDirection(direction, true);
						search_lever_command = CLAWTOHOLD;




					}

					if (walls[0] && walls[3]) {
						// Turn right
						// Wait some seconds
						search_claw_command = CLAWOPEN;
						search_motor_command = HARD_RIGHT_SEARCH;
						direction = changeDirection(direction, false);
						search_lever_command = CLAWTOHOLD;

					}
					x = changeX(direction);
					y = changeY(direction);
				}
			}
			// Cases for turning based on the the wall positions

			//Case for reconizing a wall - recording local max, when goes down past threshold record corner
			// Record relativeish direction of the wall

			if (topDistanceSensor < SENSOR_DIST_TOP_MAX) {
				if (localWallMax < topDistanceSensor) {
					//TODO : This math is wrong, something something shifted by 45 deg
					walls[(int) ((currentRotation + (MAX_ROTATION/8))/(MAX_ROTATION*4))%MAX_ROTATION] = true;
					localWallMax = topDistanceSensor;
					wallAmmount++;
				}
			}

			if ((bottomDistanceSensor) < (topDistanceSensor)
				&& (abs(bottomDistanceSensor - topDistanceSensor) > 10)) {
				if (moveToBall()) {
					//SetThe DepositingBall
				}

				//TODO : make these vars turningMax turningDistance
			}
		}
		releaseCPU();
	}
}

int changeDirection(int direction, bool left) {
	if (direction == 3 && !left) {
		return 0;
	} else if (direction == 0 && left) {
		return 3;
	} else if (left) {
		return direction -1;
	}
	return direction +1;
}

void changeX(int direction) {
	if (direction == 2) {
		currentX--;
	} else if (direction == 0) {
		currentX++;
	}
}

void changeY(int direction) {
	if (direction == 3) {
		currentY--;
	} else if (direction == 1) {
		currentY++;
	}
}

bool moveToBall() {
		search_claw_command = CLAWOPEN;
		search_motor_command = HALT;
		search_lever_command = CLAWTOHOLD;

		sleep(10);
		if ((int) ((currentRotation + (MAX_ROTATION/8))/(MAX_ROTATION*4))%MAX_ROTATION) {
			search_motor_command = HARD_RIGHT;
		} else {
			search_motor_command = HARD_LEFT;
		}

		sleep(5);

		if ((bottomDistanceSensor) < (topDistanceSensor)
		&& (abs(bottomDistanceSensor - topDistanceSensor) > 10)) {
			foundBall = true;
			bottomDistanceSensorFound = bottomDistanceSensor;
			topDistanceSensorFound = topDistanceSensor;
			search_claw_command = CLAWOPEN;
			search_motor_command = FORWARD_MOVE_SEARCH;
			search_lever_command = CLAWTOHOLD;
			sleep(20);
			if (getColorReflected(ColorSensor) > 0) {
					depositingBall = true;
					searching = false;
			}
		}
		return false;
}

task depositingBallTask () {

	// Assuming that we can get the max length of the field, we can then get the closest corner, else, return to starting point

















}




bool pickingUp = false;

task grabbingBallTask() {
	int topDistanceSensor;
	int bottomDistanceSensor;

	while (true) {
		if (pickingUp) {
			//TODO: Fix the sensor ports/ THere is a better command for finding the value anyways
			topDistanceSensor = getUSDistance(WallSensor);
			bottomDistanceSensor = getUSDistance(BallSensor);

			grabbing_motor_command = FWD;

			if (bottomDistanceSensor <= pickupThreshold) {
				grabbing_claw_command = CLAWOPEN;
				grabbing_motor_command = STOPMOVEMENT;
				grabbing_lever_command = CLAWTOGROUND;
			}
			if (getMotorEncoder(ClawVertical) < tolleranceClawFloor) {
				grabbing_claw_command = CLAWOPEN;
				grabbing_motor_command = STOPMOVEMENT;
				grabbing_lever_command = CLAWTOGROUND;
				pickingUp = true;
			}

			if (pickingUp) {
				grabbing_lever_command = CLAWTODROP;
				if (getMotorEncoder(ClawVertical) < CLAWDROPE) {
					grabbing_motor_command = STOPMOVEMENT;
					grabbing_lever_command = CLAWTOGROUND;
					sleep(timeTillClawMoves); //TODO : Fix these waits to be more accurate / move them to the movement parts
					grabbing_claw_command = CLAWCLOSE;
					grabbing_lever_command = CLAWTOHOLD;
					grabbing_motor_command = FWD;
					sleep(10);
					pickingUp = false;
					searching = false;
					depositingBall = true;

				}
			}
			sleep(5);

		}
		releaseCPU();
	}
}




//This will begin all appropriate threads, one for arbitrater, the bumper, the right hand sonar sensor
// and one for the upward facing light sensor
task main() {
	int motorCommands;
	int clawCommands;
	int leverControl;
	// Need to redo the structure of these so that they make way the fuck more sense
	startTask(moveCommand);
	startTask(searchForBallTask);
	startTask(grabbingBallTask);
	startTask(leverCommands);
	startTask(controlClaw);
	startTask(depositingBallTask);
	searching = true;

	robot_lever_command = CLAWTOHOLD;
	robot_claw_command = CLAWOPEN;

	while(true) {
		motorEncoder = getMotorEncoder(ClawVertical);
		if (searching) {
			motorCommands = search_motor_command;
			clawCommands = search_claw_command;
			leverControl = search_lever_command;
		}

		if (pickingUp) {
			motorCommands = grabbing_motor_command;
			clawCommands = grabbing_claw_command;
			leverControl = grabbing_lever_command;
		}

		if (depositingBall) {
			motorCommands = depositing_motor_command;
			clawCommands = depositing_claw_command;
			leverControl = deposting_lever_command;
		}



		robot_drive_command = motorCommands;
		robot_claw_command = clawCommands;
		robot_lever_command = leverControl;
		releaseCPU();
	}


}
