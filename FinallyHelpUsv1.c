#pragma config(Sensor, S1,     WallSensor,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     ColorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     BallSensor,     sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          LeftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          ClawMotor,     tmotorNXT, PIDControl)
#pragma config(Motor,  motorC,          ConveyMotor,   tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorD,          RightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//This file locates a ball

// Including the ball file
//#include "FinallyHelpUs2v1.c"

// Including the going back home file
//#include "FinallyHelpUs3v1.c"



//This is the set threshold I think we got somewhere from 40 to 50 will work

int minDist = 5;
int maxDist = 15;
int speedMotor = 20;
int direction = 1;

enum Directions
{
	forwardDir = 0,
	leftSoft = 25,
	rightSoft = -25,
	leftHard = 75,
	rightHard = -75
};

enum Colors
{
	yellow = 0,
	red = 1
};

enum Speed
{
	normal = -40,
	softTurn = -30,
	hardTurn = -20,
	reverseNormal = 40,
	stopMovement = 0
};

// Top distance sensor
bool enableDistSensor = false;
int stateDistSensor = 0;

// Bottom distance sensor
bool enableDistSensor2 = false;
int stateDistSensor2 = 0;

// Color sensor to detect ball color
bool enableColorSensor = false;
bool stateColorSensor = false;

enum SensorValues
{
	good,
	tooClose
};

task distanceSensors() {
	while(true) {
		if (WallSensor == false && BallSensor == true) {
			// calls the get ball (FinallyHelpUs2.c)

			wait1Msec(3);
		}
		else if (WallSensor == true && BallSensor == false) {
			// backs up and turns

		}
		else if (WallSensor = false && BallSensor = false) {
			wait1Msec(100);
	  }
	  else {

	  }
  }
	releaseCPU();
}

task moveDistanceSenseWall() {
	short sensorVal = 0;
	while(true) {
		if (enableDistSensor) {
			// If equal to the last then go straight
			// if last was both black then veer right
			// if color is white and last was black then reverse and turn?
			// if color is white and one was black turn to the one that was black and reverse a bit
			// have a wait at the end
			sensorVal = SensorValue(DistSensor);

			if (sensorVal < minDist) {
				// If the color is black on each then
				stateDistSensor = tooClose;
			} else {
				stateDistSensor = good;
			}
			wait1Msec(3);
		}
		else {
			wait1Msec(100);
		}
	}
	releaseCPU();

}

task main()
{
	//begins subthread
	startTask(ballSensor);
	startTask(conveySenseLight);

	enableDistSensor = true;
	enableLightSensor = true;
	enableTouchSensor = true;

	int waitReverseLeft = 0;

	while(true) {
		//if no line is found


		wait1Msec(1);
	}
	releaseCPU();


}
